#!/usr/bin/env python3

# Copyright (C) 2020-2021 Mathew R Gordon <https://github.com/mgord9518>

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# VERSON 0.4
# This program is in early development and is very likely to have bugs
# and lack features. Push requests and constructive criticism always
# welcome!

# CHANGELOG:
# * Renamed variables to be somewhat consistant with i3lock-color
#   exceptions are any flags that begin with "no", to avoid a double
#   negative, which makes no sense in a config file or in the code
# * Replaced more redundant code with for loops, now that there is a
#   common naming convention, although the solution is a bit hacky,
#   but better than a huge blocks of redundancy
# * Added an option for changing the greeter, verifying and wrong
#   text.
# * Added a command line option to automatically load the default on
#   launch
# * Added an option to add greeter, no input, verif, and wrong text,
#   along with their colors
# * Config now saves window size

# NOTICE:
# * There is still deprecated code that needs to be fixed/removed
# * I also plan on renaming all of the flags to be more consistant
#   with the i3lock-color command flags and with each other.

import json
import os
import sys
import time
from shutil import which

from PyQt5 import uic
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *


class CLI():
    def cmd_options(self):
        global default_settings
        default_settings = False

        helptext = '''Usage: %s [OPTION]...
Configuration program for i3lock-color

  -h, --help            Show this help and exit
  -r, --run             Execute i3lock-color with the saved configuration
  -d, --defaults        Run %s with default settings
'''.format(length='multi-line', ordinal='second')%(2 * (sys.argv[0],))

        for option in sys.argv:
            if option == '-h' or option == '-help' or option == '--help':
                print(helptext)
                exit(0)
            elif option == '-r' or option == '-run' or option == '--run':
                self.run_command()
            elif option == '-d' or option == '-defaults' or option == '--defaults':
                default_settings = True

            elif not option == sys.argv[0]:
                print("%s: unrecognized option '%s'"%(sys.argv[0], option))
                print("Try '%s --help' for more information."%(sys.argv[0]))
                exit(1)

    # Find and process the config
    def run_command(self):
        config_dir = self.get_config_dir()

        # Check if the user config exists and use it if it does
        if os.path.isfile('%s/run.bash'%(config_dir)):
            script = '%s/run.bash'%(config_dir)
        # Otherwise, use the default
        else:
            script = '../share/i3lcc/run.bash'

        print(script)

        if not os.path.isfile(script):
            print("FATAL: No user config script or default config script found!")
            exit(1)

        os.chmod(script, 0o0755)
        os.system(script)

        # os.system(ex.get_command())

        exit(0)

    def get_config_dir(self):
        if os.path.isdir('%s/.config/i3lcc'%(os.environ['HOME'])):
            config_dir = '%s/.config/i3lcc'%(os.environ['HOME'])
        else:
            try:
                os.mkdir('%s/.config/i3lcc'%(os.environ['HOME']))
            except OSError as error:
                print("%s FATAL: %s"%(sys.argv[0], error))
                os.system("notify-send %s FATAL: %s"%(sys.argv[0], error))
                exit(1)
            config_dir = '%s/.config/i3lcc'%(os.environ['HOME'])
        return(config_dir)

    def get_config(self):
        config_dir = self.get_config_dir()
        # Check if the user config exists and use it if it does
        if os.path.isfile('%s/config.json'%(config_dir)):
            config_file = '%s/config.json'%(config_dir)
        # Otherwise, use the default
        else:
            config_file = '../share/i3lcc/config.json'

        self.default_config_file = '../share/i3lcc/config.json'
        if not os.path.isfile(config_file):
            print("FATAL: No user config or default config file found!")
            exit(1)

        with open(config_file, 'r') as json_object:
            config_data = json.load(json_object)
        return(config_data)

class MainWindow(QMainWindow):
    def __init__(self):
        global default_settings

        super(MainWindow, self).__init__()
        uic.loadUi('../share/i3lcc/i3lcc-qt5.ui', self)
        self.setWindowIcon(QIcon('../share/icons/locolor/scalable/i3lcc.svg'))

        # Get the config dictionary from the JSON config file
        self.configdict = cli.get_config()

        if default_settings:
            default_settings = False
            self.load_defaults()
        else:
            self.init_widgets()

    def init_widgets(self):
        # Restrict all color lineEdits to 6 char max, hexidecimal colors. This is done so they can easily be converted into color values
        validator = QRegExpValidator(QRegExp('[a-fA-F0-9]{0,8}'))

        self.corner.setChecked(True)

        self.bg_screenshot.clicked.connect(self.disable_bg_color)
        self.bg_color.clicked.connect(self.disable_bg_screenshot)

        for w in self.tabWidget.findChildren(QCheckBox):
            flag = self.configdict[w.objectName()]
            if flag:
                w.setChecked(True)

        for w in self.tabWidget.findChildren(QRadioButton):
            if not w.objectName() == "corner" and self.configdict[w.objectName()]:
                w.setChecked(True)

        for w in self.tabWidget.findChildren(QGroupBox):
            if w.isCheckable():
                if self.configdict[w.objectName()]:
                    w.setChecked(True)
                else:
                    w.setChecked(False)

        for w in self.tabWidget.findChildren(QLineEdit):
            if "color" in w.objectName():
                w.setText(self.configdict[w.objectName()])
                w.setValidator(validator)
            elif "text" in w.objectName() or "str" in w.objectName():
                w.setText(self.configdict[w.objectName()])

        self.combo_screenshot.currentIndexChanged.connect(self.update_info)
        self.bg_image.clicked.connect(self.update_info)

        self.tbtn_image.clicked.connect(self.image_picker)
        self.button_apply.clicked.connect(self.save_config)
        self.button_about.clicked.connect(self.about_dialog)
        self.button_quit.clicked.connect(self.quit)
        self.button_preview.clicked.connect(self.preview)
        self.button_default.clicked.connect(self.load_defaults)

        # Set all widgets according to the config values
        self.tabWidget.setCurrentIndex(self.configdict['current_tab'])
        self.resize(self.configdict['window_width'], self.configdict['window_height'])

        # Background tab
        # self.color.setText(self.configdict['color'])
        self.image.setText(self.configdict['image'])
        if self.configdict['bg_mode'] == 'i3lockblur':
            self.combo_screenshot.setCurrentIndex(0)
        elif self.configdict['bg_mode'] == 'magickpixelate':
            self.combo_screenshot.setCurrentIndex(1)
            self.bg_image.setChecked(False)

    # Func to call i3lock-color using all the flags provided
    def preview(self):
        self.update_info()
        preview_command = self.command + "--no-verify"
        print("Preview command: %s"%(preview_command))
        os.system(preview_command)

    def get_command(self):
        self.update_info()
        return(self.command)

    # Update all vars by figuring out what GUI elements are switched on/off
    def update_info(self):
        # Define the command and the config dictionary, self.command will be the final shell command issued
        # the user. self.configdict will be converted to JSON and used to restore settings.
        self.command = ''
        self.configdict['current_tab'] = self.tabWidget.currentIndex()
        self.configdict['window_width'] = self.width()
        self.configdict['window_height'] = self.height()
        self.get_background()
        self.get_checkboxes()
        self.get_size()
        self.get_colors()

    def disable_bg_screenshot(self): 
        self.bg_screenshot.setChecked(False)
        self.configdict['bg_screenshot'] = False
        self.get_background()

    def disable_bg_color(self):
        self.bg_color.setChecked(False)
        self.configdict['bg_color'] = False
        self.get_background()

    def get_background(self):
        imageflag = ''
        path = self.image.text()
        self.configdict['tiling'] = False
        self.configdict['centered'] = False
        if self.centered.isChecked():
            imageflag = '--image "%s" -C '%(path)
            self.configdict['bg_img_path'] = path
            self.configdict['centered'] = True
        elif self.tiling.isChecked():
            imageflag = '--image "%s" -t '%(path)
            self.configdict['bg_img_path'] = path
            self.configdict['tiling'] = True
        else:
            imageflag = '--image "%s" '%(path)
            self.configdict['bg_img_path'] = path

        self.command = 'i3lock --locktext "" '

        if self.bg_image.isChecked() and os.path.isfile(path):
            self.configdict['bg_image'] = True
            self.command += imageflag
        else:
            self.configdict['bg_image'] = False

        if self.bg_screenshot.isChecked():
            self.configdict['bg_screenshot'] = True
            # self.configdict['bg_color'] = False
            if self.combo_screenshot.currentIndex() == 0:
                # Re-enable the image option if this is selected
                self.bg_image.setEnabled(True)
                intensity = str(round(self.bg_mode_intensity.value() / 10))
                self.command += '-c 00000000 -B %s '%(intensity)
                self.configdict['bg_mode'] = 'i3lockblur'
                self.configdict['bg_mode_intensity'] = self.bg_mode_intensity.value()
            elif self.combo_screenshot.currentIndex() == 1:
                # Disable the image option if this is selected; they aren't compatible
                self.bg_image.setEnabled(False)
                # Divide the spinbox value by 4, then take it from 30. This gives a good range of different pixelation values
                intensity = str(round(30 - self.bg_mode_intensity.value() / 4))
                # A very long, ugly command to get the screen resolution in a bash variable 'R', capture a screenshot in BMP format because it was the fastest format I found in testing, scale it down to whatever level chosen, then scale it back up to the original size, finally pipe it into i3lock-color as raw RGB data
                self.command = 'R=$(xdpyinfo | grep dimensions | sed -r "s/^[^0-9]*([0-9]+x[0-9]+).*$/\\1/");import -silent -window root bmp:- | convert bmp:- -scale %s%% -scale $R\\! rgb:- | i3lock --raw $R:rgb --image "/dev/stdin" --locktext "" -c 00000000 '%(intensity)
                self.configdict['bg_mode'] = 'magickpixelate'
                self.configdict['bg_mode_intensity'] = self.bg_mode_intensity.value()
            # elif self.combo_screenshot.currentIndex() == 2:
            #     self.bg_image.setEnabled(False)
            #     self.configdict['bg_mode'] = 'magickblur'
            #     self.configdict['bg_mode_intensity'] = self.bg_mode_intensity.value()

        elif self.bg_color.isChecked():
            self.get_colors()
            self.configdict['bg_color'] = True
            self.bg_image.setEnabled(True)

    # Check which checkboxes are selected and set the i3lock-color flags accordingly
    def get_checkboxes(self):
        for w in self.tabWidget.findChildren(QCheckBox):
            flag = w.objectName().replace("_", "-")
            if w.isChecked():
                self.configdict[w.objectName()] = True
                if w.isEnabled():
                    if flag == 'pointer':
                        flag = 'pointer default'
                    if flag == 'fork':
                        flag = ''
            else:
                self.configdict[w.objectName()] = False
                if flag == 'pointer':
                    flag = ''
                if flag == 'fork':
                    flag = 'no%s'%(flag)
                else:
                    flag = ''
            if flag:
                self.command += '--%s '%(flag)

        for w in self.tabWidget.findChildren(QGroupBox):
            if w.isCheckable():
                flag = w.objectName().replace("_", "-")
                if flag == 'bg-color' or flag == 'bg-screenshot' or flag == 'bg-image':
                    flag = ''
            if w.isChecked():
                self.configdict[w.objectName()] = True
                if flag == 'unlock-indicator':
                    flag = ''
            else:
                self.configdict[w.objectName()] = False
                if flag == 'unlock-indicator':
                    flag = 'no-%s'%(flag)
            if flag:
                self.command += '--%s '%(flag)

    # Set the radius to the value set in the Radius spin box
    def get_size(self):
        radius = str(self.spin_radius.value())
        ringwidth = str(self.spin_ringwidth.value())

        self.command += '--radius %s --ring-width %s '%(radius, ringwidth)
        self.configdict['indicator_radius'] = radius
        self.configdict['ring_width'] = ringwidth

    def get_colors(self):
        for w in self.tabWidget.findChildren(QLineEdit):
            if "color" in w.objectName():
                # The color text box only allows hexidecimal chars, if the user inputs less than 8 chars, it will default to 00000000
                if len(w.text()) < 8:
                    w.setText('00000000')
                lineedit = w.objectName()
                self.configdict[lineedit] = w.text()
                self.command += '--%s %s '%(lineedit, w.text())
            elif "text" in w.objectName() or "str" in w.objectName():
                lineedit = w.objectName()
                self.configdict[lineedit] = w.text()
                self.command += '--%s "%s" '%(lineedit, w.text())

    def image_picker(self):
        image = QFileDialog.getOpenFileName(self, "Select image location", '~', 'PNG images (*.png)')[0]
        self.image.setText(image)

    def save_config(self):
        self.update_info()
        config_dir = cli.get_config_dir()
        config_file = '%s/config.json'%(config_dir)
        try:
            f = open(config_file, 'w+')
        except OSError as error:
            print("%s FATAL: %s"%(sys.argv[0], error))
            os.system("notify-send %s FATAL: %s"%(sys.argv[0], error))
        json.dump(self.configdict, f, indent=2)
        f.close()

        config_script = '%s/run.bash'%(config_dir)
        try:
            f = open(config_script, 'w+')
        except OSError as error:
            print("%s FATAL: %s"%(sys.argv[0], error))
            os.system("notify-send %s FATAL: %s"%(sys.argv[0], error))
        f.write(self.command)
        f.close()

        os.chmod(config_script, 0o0755)

    def load_defaults(self):
        self.command = ''
        with open(cli.default_config_file, 'r') as json_object:
            self.configdict = json.load(json_object)
        self.init_widgets()

    def about_dialog(self):
        about_dialog = QMessageBox()
        about_dialog.setText("i3lcc (i3lock-color configuratorintor)")
        about_dialog.setInformativeText("A simple program for configuring i3lock-color.\n\nCopyright (C) 2020-2021 Mathew R Gordon")

        about_dialog.exec_()

    def quit(self):
        app.quit()

if __name__=="__main__":
    fullpath = os.path.abspath(sys.argv[0])
    dirpath = os.path.dirname(fullpath)
    os.chdir(dirpath)

    cli = CLI()
    cli.cmd_options()

    app=QApplication(sys.argv)
    ex = MainWindow()
    ex.show()
    sys.exit(app.exec_())
